// Copyright 2013 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// This file declares some functions used to do the integration tests of the
// Asan check functions.
#ifndef SYZYGY_INTEGRATION_TESTS_ASAN_CHECK_TESTS_H_
#define SYZYGY_INTEGRATION_TESTS_ASAN_CHECK_TESTS_H_

namespace testing {

// We need to turn off the compiler optimizations if we want these tests to be
// run as expected.
#pragma optimize( "", off )

namespace {

// NOTE: This is used to fool compiler aliasing analysis. Do not make it static
//    nor const.
int kOffsetMinusOne = -1;
int kOffsetZero = 0;
int kOffsetOne = 1;

enum InvalidAccessType {
  INVALID_READ,
  INVALID_WRITE,
};

template<typename type>
type InvalidReadFromLocation(type* location) {
  type value = (*location);
  // The access should trigger an exception and we should never hit the return
  // statement.
  ::RaiseException(EXCEPTION_NONCONTINUABLE_EXCEPTION, 0, 0, NULL);
  return static_cast<type>(0);
}

template<typename type>
void InvalidWriteToLocation(type* location, type value) {
  (*location) = value;
  // The access should trigger an exception and we should never hit this line.
  ::RaiseException(EXCEPTION_NONCONTINUABLE_EXCEPTION, 0, 0, NULL);
}

// Try to do an invalid access to a given location. This is encapsulated into a
// try-catch statement so we can catch the exception triggered by the ASan error
// handler.
template<typename type>
bool TryInvalidAccessToLocation(InvalidAccessType access_type, type* location) {
  __try {
    switch (access_type) {
      case INVALID_READ:
        InvalidReadFromLocation(location);
        break;
      case INVALID_WRITE:
        InvalidWriteToLocation(location, static_cast<type>(42));
        break;
      default:
        break;
    }
    // This should never happen.
    ::RaiseException(EXCEPTION_NONCONTINUABLE_EXCEPTION, 0, 0, NULL);
  } __except (GetExceptionCode() == EXCEPTION_ARRAY_BOUNDS_EXCEEDED ?
      EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
    return true;
  }
  return false;
}

// The following functions allow calling the ASan intercepted version of a
// function without executing the original function, thus preventing memory
// corruption from occurring.
//
// The InvalidCall* functions are simple wrappers to the function under test
// that will be instrumented, and cause an error to be raised; TryInvalidCall*
// are wrappers to InvalidCall that catch said exception, and ensure that it is
// of the expected type (i.e. generated by ASAN, and not the fall-through of
// InvalidCall). Since these functions contain error handling they will not be
// instrumented, hence the need for a separate InvalidCall wrapper.

template<typename R, typename T1>
void InvalidCall1(R function(T1), T1 arg1) {
  (*function)(arg1);
  // The call should trigger an exception and we should never hit this line.
  ::RaiseException(EXCEPTION_NONCONTINUABLE_EXCEPTION, 0, 0, NULL);
}

template<typename R, typename T1>
bool TryInvalidCall1(R function(T1), T1 arg1) {
  __try {
    InvalidCall1(function, arg1);
    // This should never happen.
    ::RaiseException(EXCEPTION_NONCONTINUABLE_EXCEPTION, 0, 0, NULL);
  } __except (GetExceptionCode() == EXCEPTION_ARRAY_BOUNDS_EXCEEDED ?
      EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
    return true;
  }
  return false;
}

template<typename R, typename T1, typename T2>
void InvalidCall2(R function(T1, T2), T1 arg1, T2 arg2) {
  (*function)(arg1, arg2);
  // The call should trigger an exception and we should never hit this line.
  ::RaiseException(EXCEPTION_NONCONTINUABLE_EXCEPTION, 0, 0, NULL);
}

template<typename R, typename T1, typename T2>
bool TryInvalidCall2(R function(T1, T2), T1 arg1, T2 arg2) {
  __try {
    InvalidCall2(function, arg1, arg2);
    // This should never happen.
    ::RaiseException(EXCEPTION_NONCONTINUABLE_EXCEPTION, 0, 0, NULL);
  } __except (GetExceptionCode() == EXCEPTION_ARRAY_BOUNDS_EXCEEDED ?
      EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
    return true;
  }
  return false;
}

template<typename R, typename T1, typename T2, typename T3>
void InvalidCall3(R function(T1, T2, T3), T1 arg1, T2 arg2, T3 arg3) {
  (*function)(arg1, arg2, arg3);
  // The call should trigger an exception and we should never hit this line.
  ::RaiseException(EXCEPTION_NONCONTINUABLE_EXCEPTION, 0, 0, NULL);
}

template<typename R, typename T1, typename T2, typename T3>
bool TryInvalidCall3(R function(T1, T2, T3), T1 arg1, T2 arg2, T3 arg3) {
  __try {
    InvalidCall3(function, arg1, arg2, arg3);
    // This should never happen.
    ::RaiseException(EXCEPTION_NONCONTINUABLE_EXCEPTION, 0, 0, NULL);
  } __except (GetExceptionCode() == EXCEPTION_ARRAY_BOUNDS_EXCEEDED ?
      EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
    return true;
  }
  return false;
}

template<typename R, typename T1, typename T2, typename T3, typename T4,
    typename T5>
void InvalidStdCall5(R __stdcall function(T1, T2, T3, T4, T5), T1 arg1, T2 arg2,
    T3 arg3, T4 arg4, T5 arg5) {
  (*function)(arg1, arg2, arg3, arg4, arg5);
  // The call should trigger an exception and we should never hit this line.
  ::RaiseException(EXCEPTION_NONCONTINUABLE_EXCEPTION, 0, 0, NULL);
}

template<typename R, typename T1, typename T2, typename T3, typename T4,
    typename T5>
bool TryInvalidStdCall5(R __stdcall function(T1, T2, T3, T4, T5), T1 arg1,
    T2 arg2, T3 arg3, T4 arg4, T5 arg5) {
  __try {
    InvalidStdCall5(function, arg1, arg2, arg3, arg4, arg5);
    // This should never happen.
    ::RaiseException(EXCEPTION_NONCONTINUABLE_EXCEPTION, 0, 0, NULL);
  } __except (GetExceptionCode() == EXCEPTION_ARRAY_BOUNDS_EXCEEDED ?
      EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
    return true;
  }
  return false;
}

}  // namespace

template<typename type>
static type AsanWriteBufferOverflow() {
  // Produce an ASAN error by writing one after the buffer.
  type* ptr = new type[1];
  ptr[kOffsetZero] = static_cast<type>(1);
  TryInvalidAccessToLocation<type>(INVALID_WRITE, &ptr[kOffsetOne]);
  type result = ptr[kOffsetZero];
  delete[] ptr;
  return result;
}

template<typename type>
static type AsanWriteBufferUnderflow() {
  // Produce an ASAN error by writing one before the buffer.
  type* ptr = new type[1];
  TryInvalidAccessToLocation<type>(INVALID_WRITE, &ptr[kOffsetMinusOne]);
  ptr[kOffsetZero] = static_cast<type>(2);
  type result = ptr[kOffsetZero];
  delete[] ptr;
  return result;
}

template<typename type>
static type AsanReadBufferOverflow() {
  // Produce an ASAN error by reading one after the buffer.
  type* ptr = new type[1];
  *ptr = static_cast<type>(42);
  TryInvalidAccessToLocation<type>(INVALID_READ, &ptr[kOffsetOne]);
  type result = ptr[kOffsetZero];
  delete[] ptr;
  return result;
}

template<typename type>
static type AsanReadBufferUnderflow() {
  // Produce an ASAN error by reading one before the buffer.
  type* ptr = new type[1];
  *ptr = static_cast<type>(42);
  TryInvalidAccessToLocation<type>(INVALID_READ, &ptr[kOffsetMinusOne]);
  type result = ptr[kOffsetZero];
  delete[] ptr;
  return result;
}

template<typename type>
static type AsanReadUseAfterFree() {
  // Produce an ASAN error by reading memory after deleting it.
  type* ptr = new type[1];
  *ptr = static_cast<type>(42);
  type result = ptr[kOffsetZero];
  delete[] ptr;
  TryInvalidAccessToLocation<type>(INVALID_READ, &ptr[kOffsetZero]);
  return result;
}

template<typename type>
static type AsanWriteUseAfterFree() {
  // Produce an ASAN error by writing memory after deleting it.
  type* ptr = new type[1];
  *ptr = static_cast<type>(42);
  type result = *ptr;
  delete[] ptr;
  TryInvalidAccessToLocation<type>(INVALID_WRITE, &ptr[kOffsetZero]);
  return result;
}

}  // namespace testing

#endif  // SYZYGY_INTEGRATION_TESTS_ASAN_CHECK_TESTS_H_
